{
    "swagger": "2.0",
    "info": {
        "contact": {}
    },
    "paths": {
        "/auth/email/check": {
            "post": {
                "description": "Exchange a valid email code for JWT tokens",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "EmailAuth"
                ],
                "summary": "Check email login code",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Client real IP address",
                        "name": "X-Real-IP",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Client User-Agent",
                        "name": "User-Agent",
                        "in": "header",
                        "required": true
                    },
                    {
                        "description": "code, reCAPTCHA token",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.CheckLoginCodeRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.TokenPair"
                        }
                    },
                    "400": {
                        "description": "missing device info or bad payload",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "code not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/auth/email/send": {
            "post": {
                "description": "Verify reCAPTCHA, then send a one-time code to the user’s email. May return tokens if password also valid.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "EmailAuth"
                ],
                "summary": "Send login code via email",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Client real IP address",
                        "name": "X-Real-IP",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Client User-Agent",
                        "name": "User-Agent",
                        "in": "header",
                        "required": true
                    },
                    {
                        "description": "email, password, reCAPTCHA token",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.LoginCodeRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.TokenPair"
                        }
                    },
                    "400": {
                        "description": "missing device info or bad payload",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "401": {
                        "description": "invalid credentials or reCAPTCHA",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/auth/jwt": {
            "post": {
                "description": "Verify reCAPTCHA, then authenticate and set JWT cookies",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Authenticate using email \u0026 password",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Client real IP address",
                        "name": "X-Real-IP",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Client User-Agent",
                        "name": "User-Agent",
                        "in": "header",
                        "required": true
                    },
                    {
                        "description": "email, password, reCAPTCHA token",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.EmailAndPasswordRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.TokenPair"
                        }
                    },
                    "400": {
                        "description": "missing device info or bad payload",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "401": {
                        "description": "invalid credentials or reCAPTCHA",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "user not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/auth/jwt/parse": {
            "post": {
                "description": "Decode a token without requiring device header",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Parse JWT claims",
                "parameters": [
                    {
                        "description": "jwt token",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.TokenRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_auth_jwt.Claims"
                        }
                    },
                    "404": {
                        "description": "token not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/auth/jwt/refresh": {
            "post": {
                "description": "Validate device header and refresh tokens, reset cookies",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Refresh JWT tokens",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Client real IP address",
                        "name": "X-Real-IP",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Client User-Agent",
                        "name": "User-Agent",
                        "in": "header",
                        "required": true
                    },
                    {
                        "description": "refresh_token",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.RefreshRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.TokenPair"
                        }
                    },
                    "400": {
                        "description": "missing device info or bad payload",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "401": {
                        "description": "token revoked or invalid",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "session not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/auth/logout": {
            "post": {
                "description": "Revoke refresh token, clear JWT cookies",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Logout user",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Authorization token",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "404": {
                        "description": "session not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/auth/oauth2/{provider}/callback": {
            "get": {
                "description": "Processes provider callback, exchanges code, sets authentication cookies, and redirects to success URL",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "OAuth2"
                ],
                "summary": "Handle OAuth2 provider callback",
                "parameters": [
                    {
                        "type": "string",
                        "description": "OAuth2 provider identifier",
                        "name": "provider",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Authorization code returned by provider",
                        "name": "code",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "State parameter for CSRF mitigation",
                        "name": "state",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Client real IP address",
                        "name": "X-Real-IP",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Client User-Agent",
                        "name": "User-Agent",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "307": {
                        "description": "Redirect to success URL"
                    },
                    "400": {
                        "description": "invalid request or missing device info",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "provider not supported or resource not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/auth/oauth2/{provider}/start": {
            "get": {
                "description": "Redirects user to the OAuth2 provider's authorization URL",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "OAuth2"
                ],
                "summary": "Start OAuth2 authentication flow",
                "parameters": [
                    {
                        "type": "string",
                        "description": "OAuth2 provider identifier",
                        "name": "provider",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "307": {
                        "description": "Redirect to provider auth URL"
                    },
                    "400": {
                        "description": "invalid provider",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/auth/oidc/{provider}/callback": {
            "get": {
                "description": "Processes provider callback, exchanges code, sets authentication cookies, and redirects to success URL",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "OIDC"
                ],
                "summary": "Handle OIDC provider callback",
                "parameters": [
                    {
                        "type": "string",
                        "description": "OIDC provider identifier",
                        "name": "provider",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Authorization code returned by provider",
                        "name": "code",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "State parameter for CSRF mitigation",
                        "name": "state",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Client real IP address",
                        "name": "X-Real-IP",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Client User-Agent",
                        "name": "User-Agent",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "307": {
                        "description": "Redirect to success URL"
                    },
                    "400": {
                        "description": "invalid request or missing device info",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "provider not supported or resource not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/auth/oidc/{provider}/start": {
            "get": {
                "description": "Redirects user to the OIDC provider's authorization URL",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "OIDC"
                ],
                "summary": "Start OIDC authentication flow",
                "parameters": [
                    {
                        "type": "string",
                        "description": "OIDC provider identifier",
                        "name": "provider",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "307": {
                        "description": "Redirect to provider auth URL"
                    },
                    "400": {
                        "description": "invalid provider",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/auth/recovery/check": {
            "post": {
                "description": "Validate a recovery code",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "PasswordRecovery"
                ],
                "summary": "Check forgot‐password code",
                "parameters": [
                    {
                        "description": "code",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.CheckForgotPasswordEmailRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "401": {
                        "description": "invalid code",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "code not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/auth/recovery/send": {
            "post": {
                "description": "Verify reCAPTCHA and send recovery email",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "PasswordRecovery"
                ],
                "summary": "Send forgot‐password email",
                "parameters": [
                    {
                        "description": "email, reCAPTCHA token",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.SendForgotPasswordEmail"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "404": {
                        "description": "email not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/auth/webauthn/login/finish": {
            "post": {
                "description": "Verifies client assertion, sets auth cookies, and returns tokens",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "WebAuthn"
                ],
                "summary": "Complete WebAuthn login",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User email header",
                        "name": "X-User-Email",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Client real IP address",
                        "name": "X-Real-IP",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Client User-Agent",
                        "name": "User-Agent",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.TokenPair"
                        }
                    },
                    "400": {
                        "description": "missing email or device info",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/auth/webauthn/login/start": {
            "post": {
                "description": "Generates an authentication challenge for the client",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "WebAuthn"
                ],
                "summary": "Start WebAuthn login",
                "parameters": [
                    {
                        "description": "Email + reCAPTCHA token",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.LoginStartRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/protocol.CredentialAssertion"
                        }
                    },
                    "401": {
                        "description": "invalid captcha",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "user not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/auth/webauthn/register/finish": {
            "post": {
                "description": "Verifies the client response to finalize registration",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "WebAuthn"
                ],
                "summary": "Complete WebAuthn registration",
                "parameters": [
                    {
                        "description": "Registration result from client",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/http.Request"
                        }
                    },
                    {
                        "type": "string",
                        "description": "Authorization token",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "400": {
                        "description": "invalid request",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/auth/webauthn/register/start": {
            "post": {
                "description": "Generates a registration challenge for the client",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "WebAuthn"
                ],
                "summary": "Start WebAuthn registration",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Authorization token",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/protocol.CredentialCreation"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/device": {
            "get": {
                "description": "Retrieve a list of registered devices for the current user",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Device"
                ],
                "summary": "List all devices for the authenticated user",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Authorization token",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "array",
                                "items": {
                                    "$ref": "#/definitions/github_com_JMURv_sso_internal_models.Device"
                                }
                            }
                        }
                    },
                    "404": {
                        "description": "no devices found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/device/{id}": {
            "get": {
                "description": "Retrieve details of a device owned by the current user",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Device"
                ],
                "summary": "Get a specific device by ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Device UUID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Authorization token",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_models.Device"
                        }
                    },
                    "400": {
                        "description": "invalid device ID path parameter",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "device not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Modify properties of a device owned by the current user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Device"
                ],
                "summary": "Update a device",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Device UUID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Update payload",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.UpdateDeviceRequest"
                        }
                    },
                    {
                        "type": "string",
                        "description": "Authorization token",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "400": {
                        "description": "invalid device ID or payload",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "device not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Remove a device owned by the current user",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Device"
                ],
                "summary": "Delete a device",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Device UUID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Authorization token",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "invalid device ID",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "device not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/perm": {
            "get": {
                "description": "Retrieve a paginated list of permissions with optional filters",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Permission"
                ],
                "summary": "List permissions",
                "parameters": [
                    {
                        "type": "integer",
                        "default": 1,
                        "description": "Page number",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 20,
                        "description": "Page size",
                        "name": "size",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.PaginatedPermissionResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Add a new permission to the system",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Permission"
                ],
                "summary": "Create a new permission",
                "parameters": [
                    {
                        "description": "Permission details",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.CreatePermissionRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Permission ID",
                        "schema": {
                            "type": "int"
                        }
                    },
                    "400": {
                        "description": "invalid request",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "409": {
                        "description": "permission already exists",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/perm/{id}": {
            "get": {
                "description": "Retrieve a specific permission",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Permission"
                ],
                "summary": "Get permission by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Permission ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_models.Permission"
                        }
                    },
                    "400": {
                        "description": "invalid ID",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "permission not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Modify an existing permission",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Permission"
                ],
                "summary": "Update a permission",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Permission ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated permission data",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.UpdatePermissionRequest"
                        }
                    },
                    {
                        "type": "string",
                        "description": "Authorization token",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "400": {
                        "description": "invalid request",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "permission not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Remove a permission by ID",
                "tags": [
                    "Permission"
                ],
                "summary": "Delete a permission",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Permission ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Authorization token",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "invalid ID",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "permission not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/roles": {
            "get": {
                "description": "Retrieve a paginated list of roles with optional filters",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Role"
                ],
                "summary": "List roles",
                "parameters": [
                    {
                        "type": "integer",
                        "default": 1,
                        "description": "Page number",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 20,
                        "description": "Page size",
                        "name": "size",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.PaginatedRoleResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Add a new role with associated permissions",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Role"
                ],
                "summary": "Create a new role",
                "parameters": [
                    {
                        "description": "Role details",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.CreateRoleRequest"
                        }
                    },
                    {
                        "type": "string",
                        "description": "Authorization token",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Role ID",
                        "schema": {
                            "type": "int"
                        }
                    },
                    "400": {
                        "description": "invalid request",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "409": {
                        "description": "role already exists",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/roles/{id}": {
            "get": {
                "description": "Retrieve details of a specific role",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Role"
                ],
                "summary": "Get role by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Role ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_models.Role"
                        }
                    },
                    "400": {
                        "description": "invalid ID",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "role not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Modify an existing role's name or permissions",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Role"
                ],
                "summary": "Update a role",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Role ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated role data",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.UpdateRoleRequest"
                        }
                    },
                    {
                        "type": "string",
                        "description": "Authorization token",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "400": {
                        "description": "invalid request",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "role not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Remove a role by ID",
                "tags": [
                    "Role"
                ],
                "summary": "Delete a role",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Role ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Authorization token",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "invalid ID",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "role not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/users": {
            "get": {
                "description": "Retrieve a paginated list of users with optional filters",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "List all users",
                "parameters": [
                    {
                        "type": "integer",
                        "default": 1,
                        "description": "Page number",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 20,
                        "description": "Page size",
                        "name": "size",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.PaginatedUserResponse"
                            }
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Creates a user with optional avatar upload",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Create a new user",
                "parameters": [
                    {
                        "type": "string",
                        "description": "JSON payload in 'data' field",
                        "name": "data",
                        "in": "formData",
                        "required": true
                    },
                    {
                        "type": "file",
                        "description": "Avatar image file",
                        "name": "avatar",
                        "in": "formData"
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.CreateUserResponse"
                        }
                    },
                    "400": {
                        "description": "bad request or file too large",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "409": {
                        "description": "user already exists",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/users/exists": {
            "post": {
                "description": "Returns 200 if user exists, 404 otherwise",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Check if a user exists by email",
                "parameters": [
                    {
                        "description": "Email payload",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.CheckEmailRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_dto.ExistsUserResponse"
                        }
                    },
                    "404": {
                        "description": "user not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/users/me": {
            "get": {
                "description": "Returns the authenticated user's profile",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Retrieve current user profile",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Bearer token, e.g. 'Bearer {jwt}'",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_models.User"
                        }
                    },
                    "401": {
                        "description": "unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "user not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Updates user profile and avatar",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Update current user",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User UUID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "JSON payload in 'data' field",
                        "name": "data",
                        "in": "formData",
                        "required": true
                    },
                    {
                        "type": "file",
                        "description": "Avatar image file",
                        "name": "avatar",
                        "in": "formData"
                    },
                    {
                        "type": "string",
                        "description": "Bearer token, e.g. 'Bearer {jwt}'",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "400": {
                        "description": "bad request",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "401": {
                        "description": "unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "user not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        },
        "/users/{id}": {
            "get": {
                "description": "Retrieve a user by their UUID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Get user by ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User UUID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_models.User"
                        }
                    },
                    "400": {
                        "description": "invalid UUID",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "user not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Updates user profile and avatar",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Update an existing user",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User UUID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "JSON payload in 'data' field",
                        "name": "data",
                        "in": "formData",
                        "required": true
                    },
                    {
                        "type": "file",
                        "description": "Avatar image file",
                        "name": "avatar",
                        "in": "formData"
                    },
                    {
                        "type": "string",
                        "description": "Bearer token, e.g. 'Bearer {jwt}'",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "400": {
                        "description": "bad request",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "401": {
                        "description": "unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "user not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Removes a user by UUID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Delete a user",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User UUID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Bearer token, e.g. 'Bearer {jwt}'",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "401": {
                        "description": "unauthorized",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "404": {
                        "description": "user not found",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    },
                    "500": {
                        "description": "internal error",
                        "schema": {
                            "$ref": "#/definitions/github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "big.Int": {
            "type": "object"
        },
        "github_com_JMURv_sso_internal_auth_jwt.Claims": {
            "type": "object",
            "properties": {
                "aud": {
                    "description": "the `aud` (Audience) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.3",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "exp": {
                    "description": "the `exp` (Expiration Time) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.4",
                    "allOf": [
                        {
                            "$ref": "#/definitions/jwt.NumericDate"
                        }
                    ]
                },
                "iat": {
                    "description": "the `iat` (Issued At) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.6",
                    "allOf": [
                        {
                            "$ref": "#/definitions/jwt.NumericDate"
                        }
                    ]
                },
                "iss": {
                    "description": "the `iss` (Issuer) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.1",
                    "type": "string"
                },
                "jti": {
                    "description": "the `jti` (JWT ID) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.7",
                    "type": "string"
                },
                "nbf": {
                    "description": "the `nbf` (Not Before) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.5",
                    "allOf": [
                        {
                            "$ref": "#/definitions/jwt.NumericDate"
                        }
                    ]
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/github_com_JMURv_sso_internal_models.Role"
                    }
                },
                "sub": {
                    "description": "the `sub` (Subject) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.2",
                    "type": "string"
                },
                "uid": {
                    "type": "string"
                }
            }
        },
        "github_com_JMURv_sso_internal_dto.CheckEmailRequest": {
            "type": "object",
            "required": [
                "email"
            ],
            "properties": {
                "email": {
                    "type": "string"
                }
            }
        },
        "github_com_JMURv_sso_internal_dto.CheckForgotPasswordEmailRequest": {
            "type": "object",
            "required": [
                "password",
                "token",
                "uidb64"
            ],
            "properties": {
                "password": {
                    "type": "string"
                },
                "token": {
                    "type": "integer"
                },
                "uidb64": {
                    "type": "string"
                }
            }
        },
        "github_com_JMURv_sso_internal_dto.CheckLoginCodeRequest": {
            "type": "object",
            "required": [
                "code",
                "email"
            ],
            "properties": {
                "code": {
                    "type": "integer"
                },
                "email": {
                    "type": "string"
                }
            }
        },
        "github_com_JMURv_sso_internal_dto.CreatePermissionRequest": {
            "type": "object",
            "required": [
                "name"
            ],
            "properties": {
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "github_com_JMURv_sso_internal_dto.CreateRoleRequest": {
            "type": "object",
            "required": [
                "name"
            ],
            "properties": {
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "permissions": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                }
            }
        },
        "github_com_JMURv_sso_internal_dto.CreateUserResponse": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                }
            }
        },
        "github_com_JMURv_sso_internal_dto.EmailAndPasswordRequest": {
            "type": "object",
            "required": [
                "email",
                "password",
                "token"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "github_com_JMURv_sso_internal_dto.ExistsUserResponse": {
            "type": "object",
            "properties": {
                "exists": {
                    "type": "boolean"
                }
            }
        },
        "github_com_JMURv_sso_internal_dto.LoginCodeRequest": {
            "type": "object",
            "required": [
                "email",
                "password",
                "token"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "github_com_JMURv_sso_internal_dto.LoginStartRequest": {
            "type": "object",
            "required": [
                "email",
                "token"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "github_com_JMURv_sso_internal_dto.PaginatedPermissionResponse": {
            "type": "object",
            "properties": {
                "count": {
                    "type": "integer"
                },
                "current_page": {
                    "type": "integer"
                },
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/github_com_JMURv_sso_internal_models.Permission"
                    }
                },
                "has_next_page": {
                    "type": "boolean"
                },
                "total_pages": {
                    "type": "integer"
                }
            }
        },
        "github_com_JMURv_sso_internal_dto.PaginatedRoleResponse": {
            "type": "object",
            "properties": {
                "count": {
                    "type": "integer"
                },
                "current_page": {
                    "type": "integer"
                },
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/github_com_JMURv_sso_internal_models.Role"
                    }
                },
                "has_next_page": {
                    "type": "boolean"
                },
                "total_pages": {
                    "type": "integer"
                }
            }
        },
        "github_com_JMURv_sso_internal_dto.PaginatedUserResponse": {
            "type": "object",
            "properties": {
                "count": {
                    "type": "integer"
                },
                "current_page": {
                    "type": "integer"
                },
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/github_com_JMURv_sso_internal_models.User"
                    }
                },
                "has_next_page": {
                    "type": "boolean"
                },
                "total_pages": {
                    "type": "integer"
                }
            }
        },
        "github_com_JMURv_sso_internal_dto.RefreshRequest": {
            "type": "object",
            "required": [
                "refresh"
            ],
            "properties": {
                "refresh": {
                    "type": "string"
                }
            }
        },
        "github_com_JMURv_sso_internal_dto.SendForgotPasswordEmail": {
            "type": "object",
            "required": [
                "email",
                "token"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "github_com_JMURv_sso_internal_dto.TokenPair": {
            "type": "object",
            "properties": {
                "access": {
                    "type": "string"
                },
                "refresh": {
                    "type": "string"
                }
            }
        },
        "github_com_JMURv_sso_internal_dto.TokenRequest": {
            "type": "object",
            "required": [
                "token"
            ],
            "properties": {
                "token": {
                    "type": "string"
                }
            }
        },
        "github_com_JMURv_sso_internal_dto.UpdateDeviceRequest": {
            "type": "object",
            "required": [
                "name"
            ],
            "properties": {
                "name": {
                    "type": "string"
                }
            }
        },
        "github_com_JMURv_sso_internal_dto.UpdatePermissionRequest": {
            "type": "object",
            "required": [
                "name"
            ],
            "properties": {
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "github_com_JMURv_sso_internal_dto.UpdateRoleRequest": {
            "type": "object",
            "required": [
                "name"
            ],
            "properties": {
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "permissions": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                }
            }
        },
        "github_com_JMURv_sso_internal_hdl_http_utils.ErrorsResponse": {
            "type": "object",
            "properties": {
                "errors": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "github_com_JMURv_sso_internal_models.Device": {
            "type": "object",
            "properties": {
                "browser": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "device_type": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "ip": {
                    "type": "string"
                },
                "last_active": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "os": {
                    "type": "string"
                },
                "ua": {
                    "type": "string"
                },
                "user_id": {
                    "type": "string"
                }
            }
        },
        "github_com_JMURv_sso_internal_models.Oauth2Connection": {
            "type": "object",
            "properties": {
                "access_token": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "expires_at": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "id_token": {
                    "type": "string"
                },
                "provider": {
                    "type": "string"
                },
                "provider_id": {
                    "type": "string"
                },
                "refresh_token": {
                    "type": "string"
                },
                "user_id": {
                    "type": "string"
                }
            }
        },
        "github_com_JMURv_sso_internal_models.Permission": {
            "type": "object",
            "properties": {
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "github_com_JMURv_sso_internal_models.Role": {
            "type": "object",
            "properties": {
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "permissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/github_com_JMURv_sso_internal_models.Permission"
                    }
                }
            }
        },
        "github_com_JMURv_sso_internal_models.User": {
            "type": "object",
            "properties": {
                "avatar": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "devices": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/github_com_JMURv_sso_internal_models.Device"
                    }
                },
                "email": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "is_active": {
                    "type": "boolean"
                },
                "is_email_verified": {
                    "type": "boolean"
                },
                "is_wa": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "oauth2_connections": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/github_com_JMURv_sso_internal_models.Oauth2Connection"
                    }
                },
                "password": {
                    "type": "string"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/github_com_JMURv_sso_internal_models.Role"
                    }
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "http.Header": {
            "type": "object",
            "additionalProperties": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            }
        },
        "http.Request": {
            "type": "object",
            "properties": {
                "body": {
                    "description": "Body is the request's body.\n\nFor client requests, a nil body means the request has no\nbody, such as a GET request. The HTTP Client's Transport\nis responsible for calling the Close method.\n\nFor server requests, the Request Body is always non-nil\nbut will return EOF immediately when no body is present.\nThe Server will close the request body. The ServeHTTP\nHandler does not need to.\n\nBody must allow Read to be called concurrently with Close.\nIn particular, calling Close should unblock a Read waiting\nfor input."
                },
                "cancel": {
                    "description": "Cancel is an optional channel whose closure indicates that the client\nrequest should be regarded as canceled. Not all implementations of\nRoundTripper may support Cancel.\n\nFor server requests, this field is not applicable.\n\nDeprecated: Set the Request's context with NewRequestWithContext\ninstead. If a Request's Cancel field and context are both\nset, it is undefined whether Cancel is respected.",
                    "type": "object"
                },
                "close": {
                    "description": "Close indicates whether to close the connection after\nreplying to this request (for servers) or after sending this\nrequest and reading its response (for clients).\n\nFor server requests, the HTTP server handles this automatically\nand this field is not needed by Handlers.\n\nFor client requests, setting this field prevents re-use of\nTCP connections between requests to the same hosts, as if\nTransport.DisableKeepAlives were set.",
                    "type": "boolean"
                },
                "contentLength": {
                    "description": "ContentLength records the length of the associated content.\nThe value -1 indicates that the length is unknown.\nValues \u003e= 0 indicate that the given number of bytes may\nbe read from Body.\n\nFor client requests, a value of 0 with a non-nil Body is\nalso treated as unknown.",
                    "type": "integer"
                },
                "form": {
                    "description": "Form contains the parsed form data, including both the URL\nfield's query parameters and the PATCH, POST, or PUT form data.\nThis field is only available after ParseForm is called.\nThe HTTP client ignores Form and uses Body instead.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/url.Values"
                        }
                    ]
                },
                "header": {
                    "description": "Header contains the request header fields either received\nby the server or to be sent by the client.\n\nIf a server received a request with header lines,\n\n\tHost: example.com\n\taccept-encoding: gzip, deflate\n\tAccept-Language: en-us\n\tfOO: Bar\n\tfoo: two\n\nthen\n\n\tHeader = map[string][]string{\n\t\t\"Accept-Encoding\": {\"gzip, deflate\"},\n\t\t\"Accept-Language\": {\"en-us\"},\n\t\t\"Foo\": {\"Bar\", \"two\"},\n\t}\n\nFor incoming requests, the Host header is promoted to the\nRequest.Host field and removed from the Header map.\n\nHTTP defines that header names are case-insensitive. The\nrequest parser implements this by using CanonicalHeaderKey,\nmaking the first character and any characters following a\nhyphen uppercase and the rest lowercase.\n\nFor client requests, certain headers such as Content-Length\nand Connection are automatically written when needed and\nvalues in Header may be ignored. See the documentation\nfor the Request.Write method.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/http.Header"
                        }
                    ]
                },
                "host": {
                    "description": "For server requests, Host specifies the host on which the\nURL is sought. For HTTP/1 (per RFC 7230, section 5.4), this\nis either the value of the \"Host\" header or the host name\ngiven in the URL itself. For HTTP/2, it is the value of the\n\":authority\" pseudo-header field.\nIt may be of the form \"host:port\". For international domain\nnames, Host may be in Punycode or Unicode form. Use\ngolang.org/x/net/idna to convert it to either format if\nneeded.\nTo prevent DNS rebinding attacks, server Handlers should\nvalidate that the Host header has a value for which the\nHandler considers itself authoritative. The included\nServeMux supports patterns registered to particular host\nnames and thus protects its registered Handlers.\n\nFor client requests, Host optionally overrides the Host\nheader to send. If empty, the Request.Write method uses\nthe value of URL.Host. Host may contain an international\ndomain name.",
                    "type": "string"
                },
                "method": {
                    "description": "Method specifies the HTTP method (GET, POST, PUT, etc.).\nFor client requests, an empty string means GET.",
                    "type": "string"
                },
                "multipartForm": {
                    "description": "MultipartForm is the parsed multipart form, including file uploads.\nThis field is only available after ParseMultipartForm is called.\nThe HTTP client ignores MultipartForm and uses Body instead.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/multipart.Form"
                        }
                    ]
                },
                "pattern": {
                    "description": "Pattern is the [ServeMux] pattern that matched the request.\nIt is empty if the request was not matched against a pattern.",
                    "type": "string"
                },
                "postForm": {
                    "description": "PostForm contains the parsed form data from PATCH, POST\nor PUT body parameters.\n\nThis field is only available after ParseForm is called.\nThe HTTP client ignores PostForm and uses Body instead.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/url.Values"
                        }
                    ]
                },
                "proto": {
                    "description": "The protocol version for incoming server requests.\n\nFor client requests, these fields are ignored. The HTTP\nclient code always uses either HTTP/1.1 or HTTP/2.\nSee the docs on Transport for details.",
                    "type": "string"
                },
                "protoMajor": {
                    "description": "1",
                    "type": "integer"
                },
                "protoMinor": {
                    "description": "0",
                    "type": "integer"
                },
                "remoteAddr": {
                    "description": "RemoteAddr allows HTTP servers and other software to record\nthe network address that sent the request, usually for\nlogging. This field is not filled in by ReadRequest and\nhas no defined format. The HTTP server in this package\nsets RemoteAddr to an \"IP:port\" address before invoking a\nhandler.\nThis field is ignored by the HTTP client.",
                    "type": "string"
                },
                "requestURI": {
                    "description": "RequestURI is the unmodified request-target of the\nRequest-Line (RFC 7230, Section 3.1.1) as sent by the client\nto a server. Usually the URL field should be used instead.\nIt is an error to set this field in an HTTP client request.",
                    "type": "string"
                },
                "response": {
                    "description": "Response is the redirect response which caused this request\nto be created. This field is only populated during client\nredirects.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/http.Response"
                        }
                    ]
                },
                "tls": {
                    "description": "TLS allows HTTP servers and other software to record\ninformation about the TLS connection on which the request\nwas received. This field is not filled in by ReadRequest.\nThe HTTP server in this package sets the field for\nTLS-enabled connections before invoking a handler;\notherwise it leaves the field nil.\nThis field is ignored by the HTTP client.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/tls.ConnectionState"
                        }
                    ]
                },
                "trailer": {
                    "description": "Trailer specifies additional headers that are sent after the request\nbody.\n\nFor server requests, the Trailer map initially contains only the\ntrailer keys, with nil values. (The client declares which trailers it\nwill later send.)  While the handler is reading from Body, it must\nnot reference Trailer. After reading from Body returns EOF, Trailer\ncan be read again and will contain non-nil values, if they were sent\nby the client.\n\nFor client requests, Trailer must be initialized to a map containing\nthe trailer keys to later send. The values may be nil or their final\nvalues. The ContentLength must be 0 or -1, to send a chunked request.\nAfter the HTTP request is sent the map values can be updated while\nthe request body is read. Once the body returns EOF, the caller must\nnot mutate Trailer.\n\nFew HTTP clients, servers, or proxies support HTTP trailers.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/http.Header"
                        }
                    ]
                },
                "transferEncoding": {
                    "description": "TransferEncoding lists the transfer encodings from outermost to\ninnermost. An empty list denotes the \"identity\" encoding.\nTransferEncoding can usually be ignored; chunked encoding is\nautomatically added and removed as necessary when sending and\nreceiving requests.",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "url": {
                    "description": "URL specifies either the URI being requested (for server\nrequests) or the URL to access (for client requests).\n\nFor server requests, the URL is parsed from the URI\nsupplied on the Request-Line as stored in RequestURI.  For\nmost requests, fields other than Path and RawQuery will be\nempty. (See RFC 7230, Section 5.3)\n\nFor client requests, the URL's Host specifies the server to\nconnect to, while the Request's Host field optionally\nspecifies the Host header value to send in the HTTP\nrequest.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/url.URL"
                        }
                    ]
                }
            }
        },
        "http.Response": {
            "type": "object",
            "properties": {
                "body": {
                    "description": "Body represents the response body.\n\nThe response body is streamed on demand as the Body field\nis read. If the network connection fails or the server\nterminates the response, Body.Read calls return an error.\n\nThe http Client and Transport guarantee that Body is always\nnon-nil, even on responses without a body or responses with\na zero-length body. It is the caller's responsibility to\nclose Body. The default HTTP client's Transport may not\nreuse HTTP/1.x \"keep-alive\" TCP connections if the Body is\nnot read to completion and closed.\n\nThe Body is automatically dechunked if the server replied\nwith a \"chunked\" Transfer-Encoding.\n\nAs of Go 1.12, the Body will also implement io.Writer\non a successful \"101 Switching Protocols\" response,\nas used by WebSockets and HTTP/2's \"h2c\" mode."
                },
                "close": {
                    "description": "Close records whether the header directed that the connection be\nclosed after reading Body. The value is advice for clients: neither\nReadResponse nor Response.Write ever closes a connection.",
                    "type": "boolean"
                },
                "contentLength": {
                    "description": "ContentLength records the length of the associated content. The\nvalue -1 indicates that the length is unknown. Unless Request.Method\nis \"HEAD\", values \u003e= 0 indicate that the given number of bytes may\nbe read from Body.",
                    "type": "integer"
                },
                "header": {
                    "description": "Header maps header keys to values. If the response had multiple\nheaders with the same key, they may be concatenated, with comma\ndelimiters.  (RFC 7230, section 3.2.2 requires that multiple headers\nbe semantically equivalent to a comma-delimited sequence.) When\nHeader values are duplicated by other fields in this struct (e.g.,\nContentLength, TransferEncoding, Trailer), the field values are\nauthoritative.\n\nKeys in the map are canonicalized (see CanonicalHeaderKey).",
                    "allOf": [
                        {
                            "$ref": "#/definitions/http.Header"
                        }
                    ]
                },
                "proto": {
                    "description": "e.g. \"HTTP/1.0\"",
                    "type": "string"
                },
                "protoMajor": {
                    "description": "e.g. 1",
                    "type": "integer"
                },
                "protoMinor": {
                    "description": "e.g. 0",
                    "type": "integer"
                },
                "request": {
                    "description": "Request is the request that was sent to obtain this Response.\nRequest's Body is nil (having already been consumed).\nThis is only populated for Client requests.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/http.Request"
                        }
                    ]
                },
                "status": {
                    "description": "e.g. \"200 OK\"",
                    "type": "string"
                },
                "statusCode": {
                    "description": "e.g. 200",
                    "type": "integer"
                },
                "tls": {
                    "description": "TLS contains information about the TLS connection on which the\nresponse was received. It is nil for unencrypted responses.\nThe pointer is shared between responses and should not be\nmodified.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/tls.ConnectionState"
                        }
                    ]
                },
                "trailer": {
                    "description": "Trailer maps trailer keys to values in the same\nformat as Header.\n\nThe Trailer initially contains only nil values, one for\neach key specified in the server's \"Trailer\" header\nvalue. Those values are not added to Header.\n\nTrailer must not be accessed concurrently with Read calls\non the Body.\n\nAfter Body.Read has returned io.EOF, Trailer will contain\nany trailer values sent by the server.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/http.Header"
                        }
                    ]
                },
                "transferEncoding": {
                    "description": "Contains transfer encodings from outer-most to inner-most. Value is\nnil, means that \"identity\" encoding is used.",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "uncompressed": {
                    "description": "Uncompressed reports whether the response was sent compressed but\nwas decompressed by the http package. When true, reading from\nBody yields the uncompressed content instead of the compressed\ncontent actually set from the server, ContentLength is set to -1,\nand the \"Content-Length\" and \"Content-Encoding\" fields are deleted\nfrom the responseHeader. To get the original response from\nthe server, set Transport.DisableCompression to true.",
                    "type": "boolean"
                }
            }
        },
        "jwt.NumericDate": {
            "type": "object",
            "properties": {
                "time.Time": {
                    "type": "string"
                }
            }
        },
        "multipart.FileHeader": {
            "type": "object",
            "properties": {
                "filename": {
                    "type": "string"
                },
                "header": {
                    "$ref": "#/definitions/textproto.MIMEHeader"
                },
                "size": {
                    "type": "integer"
                }
            }
        },
        "multipart.Form": {
            "type": "object",
            "properties": {
                "file": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "array",
                        "items": {
                            "$ref": "#/definitions/multipart.FileHeader"
                        }
                    }
                },
                "value": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "net.IPNet": {
            "type": "object",
            "properties": {
                "ip": {
                    "description": "network number",
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "mask": {
                    "description": "network mask",
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                }
            }
        },
        "pkix.AttributeTypeAndValue": {
            "type": "object",
            "properties": {
                "type": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "value": {}
            }
        },
        "pkix.Extension": {
            "type": "object",
            "properties": {
                "critical": {
                    "type": "boolean"
                },
                "id": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "value": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                }
            }
        },
        "pkix.Name": {
            "type": "object",
            "properties": {
                "commonName": {
                    "type": "string"
                },
                "country": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "extraNames": {
                    "description": "ExtraNames contains attributes to be copied, raw, into any marshaled\ndistinguished names. Values override any attributes with the same OID.\nThe ExtraNames field is not populated when parsing, see Names.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/pkix.AttributeTypeAndValue"
                    }
                },
                "locality": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "names": {
                    "description": "Names contains all parsed attributes. When parsing distinguished names,\nthis can be used to extract non-standard attributes that are not parsed\nby this package. When marshaling to RDNSequences, the Names field is\nignored, see ExtraNames.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/pkix.AttributeTypeAndValue"
                    }
                },
                "organization": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "organizationalUnit": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "postalCode": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "province": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "serialNumber": {
                    "type": "string"
                },
                "streetAddress": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "protocol.AttestationFormat": {
            "type": "string",
            "enum": [
                "packed",
                "tpm",
                "android-key",
                "android-safetynet",
                "fido-u2f",
                "apple",
                "none"
            ],
            "x-enum-varnames": [
                "AttestationFormatPacked",
                "AttestationFormatTPM",
                "AttestationFormatAndroidKey",
                "AttestationFormatAndroidSafetyNet",
                "AttestationFormatFIDOUniversalSecondFactor",
                "AttestationFormatApple",
                "AttestationFormatNone"
            ]
        },
        "protocol.AuthenticationExtensions": {
            "type": "object",
            "additionalProperties": {}
        },
        "protocol.AuthenticatorAttachment": {
            "type": "string",
            "enum": [
                "platform",
                "cross-platform"
            ],
            "x-enum-varnames": [
                "Platform",
                "CrossPlatform"
            ]
        },
        "protocol.AuthenticatorSelection": {
            "type": "object",
            "properties": {
                "authenticatorAttachment": {
                    "description": "AuthenticatorAttachment If this member is present, eligible authenticators are filtered to only\nauthenticators attached with the specified AuthenticatorAttachment enum.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/protocol.AuthenticatorAttachment"
                        }
                    ]
                },
                "requireResidentKey": {
                    "description": "RequireResidentKey this member describes the Relying Party's requirements regarding resident\ncredentials. If the parameter is set to true, the authenticator MUST create a client-side-resident\npublic key credential source when creating a public key credential.",
                    "type": "boolean"
                },
                "residentKey": {
                    "description": "ResidentKey this member describes the Relying Party's requirements regarding resident\ncredentials per Webauthn Level 2.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/protocol.ResidentKeyRequirement"
                        }
                    ]
                },
                "userVerification": {
                    "description": "UserVerification This member describes the Relying Party's requirements regarding user verification for\nthe create() operation. Eligible authenticators are filtered to only those capable of satisfying this\nrequirement.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/protocol.UserVerificationRequirement"
                        }
                    ]
                }
            }
        },
        "protocol.AuthenticatorTransport": {
            "type": "string",
            "enum": [
                "usb",
                "nfc",
                "ble",
                "smart-card",
                "hybrid",
                "internal"
            ],
            "x-enum-varnames": [
                "USB",
                "NFC",
                "BLE",
                "SmartCard",
                "Hybrid",
                "Internal"
            ]
        },
        "protocol.ConveyancePreference": {
            "type": "string",
            "enum": [
                "none",
                "indirect",
                "direct",
                "enterprise"
            ],
            "x-enum-varnames": [
                "PreferNoAttestation",
                "PreferIndirectAttestation",
                "PreferDirectAttestation",
                "PreferEnterpriseAttestation"
            ]
        },
        "protocol.CredentialAssertion": {
            "type": "object",
            "properties": {
                "mediation": {
                    "$ref": "#/definitions/protocol.CredentialMediationRequirement"
                },
                "publicKey": {
                    "$ref": "#/definitions/protocol.PublicKeyCredentialRequestOptions"
                }
            }
        },
        "protocol.CredentialCreation": {
            "type": "object",
            "properties": {
                "mediation": {
                    "$ref": "#/definitions/protocol.CredentialMediationRequirement"
                },
                "publicKey": {
                    "$ref": "#/definitions/protocol.PublicKeyCredentialCreationOptions"
                }
            }
        },
        "protocol.CredentialDescriptor": {
            "type": "object",
            "properties": {
                "id": {
                    "description": "CredentialID The ID of a credential to allow/disallow.",
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "transports": {
                    "description": "The authenticator transports that can be used.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/protocol.AuthenticatorTransport"
                    }
                },
                "type": {
                    "description": "The valid credential types.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/protocol.CredentialType"
                        }
                    ]
                }
            }
        },
        "protocol.CredentialMediationRequirement": {
            "type": "string",
            "enum": [
                "silent",
                "optional",
                "conditional",
                "required"
            ],
            "x-enum-varnames": [
                "MediationSilent",
                "MediationOptional",
                "MediationConditional",
                "MediationRequired"
            ]
        },
        "protocol.CredentialParameter": {
            "type": "object",
            "properties": {
                "alg": {
                    "$ref": "#/definitions/webauthncose.COSEAlgorithmIdentifier"
                },
                "type": {
                    "$ref": "#/definitions/protocol.CredentialType"
                }
            }
        },
        "protocol.CredentialType": {
            "type": "string",
            "enum": [
                "public-key"
            ],
            "x-enum-varnames": [
                "PublicKeyCredentialType"
            ]
        },
        "protocol.PublicKeyCredentialCreationOptions": {
            "type": "object",
            "properties": {
                "attestation": {
                    "$ref": "#/definitions/protocol.ConveyancePreference"
                },
                "attestationFormats": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/protocol.AttestationFormat"
                    }
                },
                "authenticatorSelection": {
                    "$ref": "#/definitions/protocol.AuthenticatorSelection"
                },
                "challenge": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "excludeCredentials": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/protocol.CredentialDescriptor"
                    }
                },
                "extensions": {
                    "$ref": "#/definitions/protocol.AuthenticationExtensions"
                },
                "hints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/protocol.PublicKeyCredentialHints"
                    }
                },
                "pubKeyCredParams": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/protocol.CredentialParameter"
                    }
                },
                "rp": {
                    "$ref": "#/definitions/protocol.RelyingPartyEntity"
                },
                "timeout": {
                    "type": "integer"
                },
                "user": {
                    "$ref": "#/definitions/protocol.UserEntity"
                }
            }
        },
        "protocol.PublicKeyCredentialHints": {
            "type": "string",
            "enum": [
                "security-key",
                "client-device",
                "hybrid"
            ],
            "x-enum-varnames": [
                "PublicKeyCredentialHintSecurityKey",
                "PublicKeyCredentialHintClientDevice",
                "PublicKeyCredentialHintHybrid"
            ]
        },
        "protocol.PublicKeyCredentialRequestOptions": {
            "type": "object",
            "properties": {
                "allowCredentials": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/protocol.CredentialDescriptor"
                    }
                },
                "challenge": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "extensions": {
                    "$ref": "#/definitions/protocol.AuthenticationExtensions"
                },
                "hints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/protocol.PublicKeyCredentialHints"
                    }
                },
                "rpId": {
                    "type": "string"
                },
                "timeout": {
                    "type": "integer"
                },
                "userVerification": {
                    "$ref": "#/definitions/protocol.UserVerificationRequirement"
                }
            }
        },
        "protocol.RelyingPartyEntity": {
            "type": "object",
            "properties": {
                "id": {
                    "description": "A unique identifier for the Relying Party entity, which sets the RP ID.",
                    "type": "string"
                },
                "name": {
                    "description": "A human-palatable name for the entity. Its function depends on what the PublicKeyCredentialEntity represents:\n\nWhen inherited by PublicKeyCredentialRpEntity it is a human-palatable identifier for the Relying Party,\nintended only for display. For example, \"ACME Corporation\", \"Wonderful Widgets, Inc.\" or \"ОАО Примертех\".\n\nWhen inherited by PublicKeyCredentialUserEntity, it is a human-palatable identifier for a user account. It is\nintended only for display, i.e., aiding the user in determining the difference between user accounts with similar\ndisplayNames. For example, \"alexm\", \"alex.p.mueller@example.com\" or \"+14255551234\".",
                    "type": "string"
                }
            }
        },
        "protocol.ResidentKeyRequirement": {
            "type": "string",
            "enum": [
                "discouraged",
                "preferred",
                "required"
            ],
            "x-enum-varnames": [
                "ResidentKeyRequirementDiscouraged",
                "ResidentKeyRequirementPreferred",
                "ResidentKeyRequirementRequired"
            ]
        },
        "protocol.UserEntity": {
            "type": "object",
            "properties": {
                "displayName": {
                    "description": "A human-palatable name for the user account, intended only for display.\nFor example, \"Alex P. Müller\" or \"田中 倫\". The Relying Party SHOULD let\nthe user choose this, and SHOULD NOT restrict the choice more than necessary.",
                    "type": "string"
                },
                "id": {
                    "description": "ID is the user handle of the user account entity. To ensure secure operation,\nauthentication and authorization decisions MUST be made on the basis of this id\nmember, not the displayName nor name members. See Section 6.1 of\n[RFC8266](https://www.w3.org/TR/webauthn/#biblio-rfc8266)."
                },
                "name": {
                    "description": "A human-palatable name for the entity. Its function depends on what the PublicKeyCredentialEntity represents:\n\nWhen inherited by PublicKeyCredentialRpEntity it is a human-palatable identifier for the Relying Party,\nintended only for display. For example, \"ACME Corporation\", \"Wonderful Widgets, Inc.\" or \"ОАО Примертех\".\n\nWhen inherited by PublicKeyCredentialUserEntity, it is a human-palatable identifier for a user account. It is\nintended only for display, i.e., aiding the user in determining the difference between user accounts with similar\ndisplayNames. For example, \"alexm\", \"alex.p.mueller@example.com\" or \"+14255551234\".",
                    "type": "string"
                }
            }
        },
        "protocol.UserVerificationRequirement": {
            "type": "string",
            "enum": [
                "required",
                "preferred",
                "discouraged"
            ],
            "x-enum-comments": {
                "VerificationPreferred": "This is the default"
            },
            "x-enum-varnames": [
                "VerificationRequired",
                "VerificationPreferred",
                "VerificationDiscouraged"
            ]
        },
        "textproto.MIMEHeader": {
            "type": "object",
            "additionalProperties": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            }
        },
        "tls.ConnectionState": {
            "type": "object",
            "properties": {
                "cipherSuite": {
                    "description": "CipherSuite is the cipher suite negotiated for the connection (e.g.\nTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_AES_128_GCM_SHA256).",
                    "type": "integer"
                },
                "didResume": {
                    "description": "DidResume is true if this connection was successfully resumed from a\nprevious session with a session ticket or similar mechanism.",
                    "type": "boolean"
                },
                "echaccepted": {
                    "description": "ECHAccepted indicates if Encrypted Client Hello was offered by the client\nand accepted by the server. Currently, ECH is supported only on the\nclient side.",
                    "type": "boolean"
                },
                "handshakeComplete": {
                    "description": "HandshakeComplete is true if the handshake has concluded.",
                    "type": "boolean"
                },
                "negotiatedProtocol": {
                    "description": "NegotiatedProtocol is the application protocol negotiated with ALPN.",
                    "type": "string"
                },
                "negotiatedProtocolIsMutual": {
                    "description": "NegotiatedProtocolIsMutual used to indicate a mutual NPN negotiation.\n\nDeprecated: this value is always true.",
                    "type": "boolean"
                },
                "ocspresponse": {
                    "description": "OCSPResponse is a stapled Online Certificate Status Protocol (OCSP)\nresponse provided by the peer for the leaf certificate, if any.",
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "peerCertificates": {
                    "description": "PeerCertificates are the parsed certificates sent by the peer, in the\norder in which they were sent. The first element is the leaf certificate\nthat the connection is verified against.\n\nOn the client side, it can't be empty. On the server side, it can be\nempty if Config.ClientAuth is not RequireAnyClientCert or\nRequireAndVerifyClientCert.\n\nPeerCertificates and its contents should not be modified.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/x509.Certificate"
                    }
                },
                "serverName": {
                    "description": "ServerName is the value of the Server Name Indication extension sent by\nthe client. It's available both on the server and on the client side.",
                    "type": "string"
                },
                "signedCertificateTimestamps": {
                    "description": "SignedCertificateTimestamps is a list of SCTs provided by the peer\nthrough the TLS handshake for the leaf certificate, if any.",
                    "type": "array",
                    "items": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        }
                    }
                },
                "tlsunique": {
                    "description": "TLSUnique contains the \"tls-unique\" channel binding value (see RFC 5929,\nSection 3). This value will be nil for TLS 1.3 connections and for\nresumed connections that don't support Extended Master Secret (RFC 7627).",
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "verifiedChains": {
                    "description": "VerifiedChains is a list of one or more chains where the first element is\nPeerCertificates[0] and the last element is from Config.RootCAs (on the\nclient side) or Config.ClientCAs (on the server side).\n\nOn the client side, it's set if Config.InsecureSkipVerify is false. On\nthe server side, it's set if Config.ClientAuth is VerifyClientCertIfGiven\n(and the peer provided a certificate) or RequireAndVerifyClientCert.\n\nVerifiedChains and its contents should not be modified.",
                    "type": "array",
                    "items": {
                        "type": "array",
                        "items": {
                            "$ref": "#/definitions/x509.Certificate"
                        }
                    }
                },
                "version": {
                    "description": "Version is the TLS version used by the connection (e.g. VersionTLS12).",
                    "type": "integer"
                }
            }
        },
        "url.URL": {
            "type": "object",
            "properties": {
                "forceQuery": {
                    "description": "append a query ('?') even if RawQuery is empty",
                    "type": "boolean"
                },
                "fragment": {
                    "description": "fragment for references, without '#'",
                    "type": "string"
                },
                "host": {
                    "description": "host or host:port (see Hostname and Port methods)",
                    "type": "string"
                },
                "omitHost": {
                    "description": "do not emit empty host (authority)",
                    "type": "boolean"
                },
                "opaque": {
                    "description": "encoded opaque data",
                    "type": "string"
                },
                "path": {
                    "description": "path (relative paths may omit leading slash)",
                    "type": "string"
                },
                "rawFragment": {
                    "description": "encoded fragment hint (see EscapedFragment method)",
                    "type": "string"
                },
                "rawPath": {
                    "description": "encoded path hint (see EscapedPath method)",
                    "type": "string"
                },
                "rawQuery": {
                    "description": "encoded query values, without '?'",
                    "type": "string"
                },
                "scheme": {
                    "type": "string"
                },
                "user": {
                    "description": "username and password information",
                    "allOf": [
                        {
                            "$ref": "#/definitions/url.Userinfo"
                        }
                    ]
                }
            }
        },
        "url.Userinfo": {
            "type": "object"
        },
        "url.Values": {
            "type": "object",
            "additionalProperties": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            }
        },
        "webauthncose.COSEAlgorithmIdentifier": {
            "type": "integer",
            "enum": [
                -7,
                -8,
                -35,
                -36,
                -37,
                -38,
                -39,
                -47,
                -257,
                -258,
                -259,
                -65535
            ],
            "x-enum-varnames": [
                "AlgES256",
                "AlgEdDSA",
                "AlgES384",
                "AlgES512",
                "AlgPS256",
                "AlgPS384",
                "AlgPS512",
                "AlgES256K",
                "AlgRS256",
                "AlgRS384",
                "AlgRS512",
                "AlgRS1"
            ]
        },
        "x509.Certificate": {
            "type": "object",
            "properties": {
                "authorityKeyId": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "basicConstraintsValid": {
                    "description": "BasicConstraintsValid indicates whether IsCA, MaxPathLen,\nand MaxPathLenZero are valid.",
                    "type": "boolean"
                },
                "crldistributionPoints": {
                    "description": "CRL Distribution Points",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "dnsnames": {
                    "description": "Subject Alternate Name values. (Note that these values may not be valid\nif invalid values were contained within a parsed certificate. For\nexample, an element of DNSNames may not be a valid DNS domain name.)",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "emailAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "excludedDNSDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "excludedEmailAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "excludedIPRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/net.IPNet"
                    }
                },
                "excludedURIDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "extKeyUsage": {
                    "description": "Sequence of extended key usages.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/x509.ExtKeyUsage"
                    }
                },
                "extensions": {
                    "description": "Extensions contains raw X.509 extensions. When parsing certificates,\nthis can be used to extract non-critical extensions that are not\nparsed by this package. When marshaling certificates, the Extensions\nfield is ignored, see ExtraExtensions.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/pkix.Extension"
                    }
                },
                "extraExtensions": {
                    "description": "ExtraExtensions contains extensions to be copied, raw, into any\nmarshaled certificates. Values override any extensions that would\notherwise be produced based on the other fields. The ExtraExtensions\nfield is not populated when parsing certificates, see Extensions.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/pkix.Extension"
                    }
                },
                "ipaddresses": {
                    "type": "array",
                    "items": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        }
                    }
                },
                "isCA": {
                    "type": "boolean"
                },
                "issuer": {
                    "$ref": "#/definitions/pkix.Name"
                },
                "issuingCertificateURL": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "keyUsage": {
                    "$ref": "#/definitions/x509.KeyUsage"
                },
                "maxPathLen": {
                    "description": "MaxPathLen and MaxPathLenZero indicate the presence and\nvalue of the BasicConstraints' \"pathLenConstraint\".\n\nWhen parsing a certificate, a positive non-zero MaxPathLen\nmeans that the field was specified, -1 means it was unset,\nand MaxPathLenZero being true mean that the field was\nexplicitly set to zero. The case of MaxPathLen==0 with MaxPathLenZero==false\nshould be treated equivalent to -1 (unset).\n\nWhen generating a certificate, an unset pathLenConstraint\ncan be requested with either MaxPathLen == -1 or using the\nzero value for both MaxPathLen and MaxPathLenZero.",
                    "type": "integer"
                },
                "maxPathLenZero": {
                    "description": "MaxPathLenZero indicates that BasicConstraintsValid==true\nand MaxPathLen==0 should be interpreted as an actual\nmaximum path length of zero. Otherwise, that combination is\ninterpreted as MaxPathLen not being set.",
                    "type": "boolean"
                },
                "notAfter": {
                    "description": "Validity bounds.",
                    "type": "string"
                },
                "notBefore": {
                    "description": "Validity bounds.",
                    "type": "string"
                },
                "ocspserver": {
                    "description": "RFC 5280, 4.2.2.1 (Authority Information Access)",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "permittedDNSDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "permittedDNSDomainsCritical": {
                    "description": "Name constraints",
                    "type": "boolean"
                },
                "permittedEmailAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "permittedIPRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/net.IPNet"
                    }
                },
                "permittedURIDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "policies": {
                    "description": "Policies contains all policy identifiers included in the certificate.\nIn Go 1.22, encoding/gob cannot handle and ignores this field.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/x509.OID"
                    }
                },
                "policyIdentifiers": {
                    "description": "PolicyIdentifiers contains asn1.ObjectIdentifiers, the components\nof which are limited to int32. If a certificate contains a policy which\ncannot be represented by asn1.ObjectIdentifier, it will not be included in\nPolicyIdentifiers, but will be present in Policies, which contains all parsed\npolicy OIDs.",
                    "type": "array",
                    "items": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        }
                    }
                },
                "publicKey": {},
                "publicKeyAlgorithm": {
                    "$ref": "#/definitions/x509.PublicKeyAlgorithm"
                },
                "raw": {
                    "description": "Complete ASN.1 DER content (certificate, signature algorithm and signature).",
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "rawIssuer": {
                    "description": "DER encoded Issuer",
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "rawSubject": {
                    "description": "DER encoded Subject",
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "rawSubjectPublicKeyInfo": {
                    "description": "DER encoded SubjectPublicKeyInfo.",
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "rawTBSCertificate": {
                    "description": "Certificate part of raw ASN.1 DER content.",
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "serialNumber": {
                    "$ref": "#/definitions/big.Int"
                },
                "signature": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "signatureAlgorithm": {
                    "$ref": "#/definitions/x509.SignatureAlgorithm"
                },
                "subject": {
                    "$ref": "#/definitions/pkix.Name"
                },
                "subjectKeyId": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "unhandledCriticalExtensions": {
                    "description": "UnhandledCriticalExtensions contains a list of extension IDs that\nwere not (fully) processed when parsing. Verify will fail if this\nslice is non-empty, unless verification is delegated to an OS\nlibrary which understands all the critical extensions.\n\nUsers can access these extensions using Extensions and can remove\nelements from this slice if they believe that they have been\nhandled.",
                    "type": "array",
                    "items": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        }
                    }
                },
                "unknownExtKeyUsage": {
                    "description": "Encountered extended key usages unknown to this package.",
                    "type": "array",
                    "items": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        }
                    }
                },
                "uris": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/url.URL"
                    }
                },
                "version": {
                    "type": "integer"
                }
            }
        },
        "x509.ExtKeyUsage": {
            "type": "integer",
            "enum": [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "x-enum-varnames": [
                "ExtKeyUsageAny",
                "ExtKeyUsageServerAuth",
                "ExtKeyUsageClientAuth",
                "ExtKeyUsageCodeSigning",
                "ExtKeyUsageEmailProtection",
                "ExtKeyUsageIPSECEndSystem",
                "ExtKeyUsageIPSECTunnel",
                "ExtKeyUsageIPSECUser",
                "ExtKeyUsageTimeStamping",
                "ExtKeyUsageOCSPSigning",
                "ExtKeyUsageMicrosoftServerGatedCrypto",
                "ExtKeyUsageNetscapeServerGatedCrypto",
                "ExtKeyUsageMicrosoftCommercialCodeSigning",
                "ExtKeyUsageMicrosoftKernelCodeSigning"
            ]
        },
        "x509.KeyUsage": {
            "type": "integer",
            "enum": [
                1,
                2,
                4,
                8,
                16,
                32,
                64,
                128,
                256
            ],
            "x-enum-varnames": [
                "KeyUsageDigitalSignature",
                "KeyUsageContentCommitment",
                "KeyUsageKeyEncipherment",
                "KeyUsageDataEncipherment",
                "KeyUsageKeyAgreement",
                "KeyUsageCertSign",
                "KeyUsageCRLSign",
                "KeyUsageEncipherOnly",
                "KeyUsageDecipherOnly"
            ]
        },
        "x509.OID": {
            "type": "object"
        },
        "x509.PublicKeyAlgorithm": {
            "type": "integer",
            "enum": [
                0,
                1,
                2,
                3,
                4
            ],
            "x-enum-comments": {
                "DSA": "Only supported for parsing."
            },
            "x-enum-varnames": [
                "UnknownPublicKeyAlgorithm",
                "RSA",
                "DSA",
                "ECDSA",
                "Ed25519"
            ]
        },
        "x509.SignatureAlgorithm": {
            "type": "integer",
            "enum": [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ],
            "x-enum-comments": {
                "DSAWithSHA1": "Unsupported.",
                "DSAWithSHA256": "Unsupported.",
                "ECDSAWithSHA1": "Only supported for signing, and verification of CRLs, CSRs, and OCSP responses.",
                "MD2WithRSA": "Unsupported.",
                "MD5WithRSA": "Only supported for signing, not verification.",
                "SHA1WithRSA": "Only supported for signing, and verification of CRLs, CSRs, and OCSP responses."
            },
            "x-enum-varnames": [
                "UnknownSignatureAlgorithm",
                "MD2WithRSA",
                "MD5WithRSA",
                "SHA1WithRSA",
                "SHA256WithRSA",
                "SHA384WithRSA",
                "SHA512WithRSA",
                "DSAWithSHA1",
                "DSAWithSHA256",
                "ECDSAWithSHA1",
                "ECDSAWithSHA256",
                "ECDSAWithSHA384",
                "ECDSAWithSHA512",
                "SHA256WithRSAPSS",
                "SHA384WithRSAPSS",
                "SHA512WithRSAPSS",
                "PureEd25519"
            ]
        }
    }
}